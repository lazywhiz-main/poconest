<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Card Network Map</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&family=JetBrains+Mono:wght@300;400;500;600&display=swap" rel="stylesheet">
    <style>
        /* CSS Variables - „É¢„ÉÄ„É≥„ÉÜ„ÉÉ„ÇØ„Éá„Ç∂„Ç§„É≥„Ç∑„Çπ„ÉÜ„É† */
        :root {
            /* Colors */
            --primary-green: #00ff88;
            --primary-green-dark: #00cc6a;
            --primary-blue: #64b5f6;
            --primary-orange: #ffa500;
            --primary-red: #ff6b6b;
            --primary-purple: #9c27b0;
            --primary-cyan: #26c6da;
            --primary-yellow: #ffd93d;
            
            /* Background */
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a2e;
            --bg-tertiary: #333366;
            --bg-quaternary: #45475a;
            
            /* Text */
            --text-primary: #e2e8f0;
            --text-secondary: #a6adc8;
            --text-muted: #6c7086;
            --text-inverse: #0f0f23;
            
            /* Border */
            --border-primary: #333366;
            --border-secondary: #45475a;
            
            /* Typography */
            --font-family-text: 'Space Grotesk', sans-serif;
            --font-family-mono: 'JetBrains Mono', monospace;
            
            /* Transitions */
            --transition-fast: 0.15s ease;
            --transition-normal: 0.2s ease;
        }

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: var(--font-family-text);
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            user-select: none;
        }

        .network-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: grab;
        }

        .network-container.dragging {
            cursor: grabbing;
        }

        .network-canvas {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        .network-svg {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
            pointer-events: none;
        }

        .network-cards {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        .card {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 12px 16px;
            cursor: pointer;
            transition: all var(--transition-normal);
            transform-origin: center;
            min-width: 120px;
            max-width: 200px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .card:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 20px rgba(0, 255, 136, 0.3);
            border-color: var(--primary-green);
            z-index: 10;
        }

        .card.selected {
            border-color: var(--primary-green);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
            z-index: 15;
        }

        .card.highlighted {
            border-color: var(--primary-yellow);
            box-shadow: 0 0 12px rgba(255, 211, 61, 0.4);
        }

        /* Card types with subtle visual differences */
        .card.type-insight {
            border-left: 4px solid var(--primary-purple);
        }

        .card.type-theme {
            border-left: 4px solid var(--primary-blue);
        }

        .card.type-concept {
            border-left: 4px solid var(--primary-cyan);
        }

        .card.type-action {
            border-left: 4px solid var(--primary-orange);
        }

        .card.type-question {
            border-left: 4px solid var(--primary-yellow);
        }

        .card-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 6px;
            line-height: 1.3;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .card-meta {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            color: var(--text-muted);
            font-family: var(--font-family-mono);
            margin-bottom: 8px;
        }

        .card-author {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 9px;
        }

        .card-date {
            opacity: 0.7;
        }

        .card-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }

        .card-tag {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 2px 6px;
            border-radius: 8px;
            font-size: 9px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-family: var(--font-family-mono);
        }

        .card-tag.tag-ux { background: rgba(100, 181, 246, 0.2); color: var(--primary-blue); }
        .card-tag.tag-psychology { background: rgba(156, 39, 176, 0.2); color: var(--primary-purple); }
        .card-tag.tag-design { background: rgba(255, 165, 0, 0.2); color: var(--primary-orange); }
        .card-tag.tag-research { background: rgba(38, 198, 218, 0.2); color: var(--primary-cyan); }

        /* Connection lines */
        .connection-line {
            stroke: var(--text-muted);
            stroke-width: 1;
            fill: none;
            opacity: 0.3;
            transition: all var(--transition-normal);
        }

        .connection-line.active {
            opacity: 0.8;
            stroke-width: 2;
            stroke: var(--primary-green);
            filter: drop-shadow(0 0 3px var(--primary-green));
        }

        .connection-line.related {
            opacity: 0.6;
            stroke: var(--primary-blue);
            stroke-width: 1.5;
        }

        .connection-line.strong {
            stroke-width: 2;
            opacity: 0.6;
        }

        /* Cluster highlights */
        .cluster-highlight {
            fill: none;
            stroke: var(--primary-green);
            stroke-width: 2;
            stroke-dasharray: 10,5;
            opacity: 0.6;
            filter: drop-shadow(0 0 6px var(--primary-green));
        }

        /* Cluster labels */
        .cluster-label {
            position: absolute;
            background: rgba(0, 255, 136, 0.9);
            color: var(--text-inverse);
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 600;
            font-family: var(--font-family-mono);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            pointer-events: none;
            z-index: 20;
            backdrop-filter: blur(4px);
            border: 1px solid var(--primary-green);
            box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
            transition: all var(--transition-normal);
        }

        .cluster-label.theme-ux {
            background: rgba(100, 181, 246, 0.9);
            border-color: var(--primary-blue);
            box-shadow: 0 4px 12px rgba(100, 181, 246, 0.3);
        }

        .cluster-label.theme-psychology {
            background: rgba(156, 39, 176, 0.9);
            border-color: var(--primary-purple);
            box-shadow: 0 4px 12px rgba(156, 39, 176, 0.3);
        }

        .cluster-label.theme-design {
            background: rgba(255, 165, 0, 0.9);
            border-color: var(--primary-orange);
            box-shadow: 0 4px 12px rgba(255, 165, 0, 0.3);
        }

        .cluster-label.theme-research {
            background: rgba(38, 198, 218, 0.9);
            border-color: var(--primary-cyan);
            box-shadow: 0 4px 12px rgba(38, 198, 218, 0.3);
        }

        .cluster-label.size-large {
            font-size: 14px;
            padding: 8px 16px;
        }

        .cluster-label.size-small {
            font-size: 10px;
            padding: 4px 8px;
        }

        /* Auto-generated region labels */
        .region-label {
            position: absolute;
            background: rgba(15, 15, 35, 0.8);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            font-family: var(--font-family-text);
            pointer-events: none;
            z-index: 15;
            backdrop-filter: blur(8px);
            border: 1px solid var(--border-primary);
            opacity: 0.8;
        }

        /* Density indicators */
        .density-indicator {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--primary-green);
            border-radius: 50%;
            opacity: 0.6;
            pointer-events: none;
            z-index: 5;
            animation: pulse 2s infinite;
        }

        .density-indicator.high {
            background: var(--primary-red);
            width: 12px;
            height: 12px;
        }

        .density-indicator.medium {
            background: var(--primary-orange);
            width: 10px;
            height: 10px;
        }

        .density-indicator.low {
            background: var(--primary-cyan);
            width: 6px;
            height: 6px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        /* Controls */
        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            color: var(--text-secondary);
            padding: 12px 16px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-normal);
            font-family: var(--font-family-mono);
            min-width: 140px;
            text-align: center;
        }

        .control-btn:hover {
            background: var(--primary-green);
            color: var(--text-inverse);
            border-color: var(--primary-green);
        }

        .control-btn.active {
            background: var(--primary-green);
            color: var(--text-inverse);
            border-color: var(--primary-green);
        }

        /* Info panel */
        .info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 20px;
            max-width: 350px;
            opacity: 0;
            transform: translateX(20px);
            transition: all var(--transition-normal);
        }

        .info-panel.show {
            opacity: 1;
            transform: translateX(0);
        }

        .info-title {
            color: var(--primary-green);
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            font-family: var(--font-family-text);
        }

        .info-content {
            color: var(--text-secondary);
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 16px;
        }

        .info-metadata {
            font-size: 12px;
            color: var(--text-muted);
            font-family: var(--font-family-mono);
        }

        .info-connections {
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-primary);
        }

        .info-connections-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .connection-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .connection-type {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 6px;
            font-size: 9px;
            color: var(--primary-green);
        }

        /* Filter panel */
        .filter-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 10;
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 12px;
            padding: 16px;
            min-width: 200px;
        }

        .filter-title {
            color: var(--text-primary);
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            font-family: var(--font-family-mono);
        }

        .filter-group {
            margin-bottom: 12px;
        }

        .filter-label {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            font-family: var(--font-family-mono);
        }

        .filter-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .filter-tag {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
            color: var(--text-secondary);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 10px;
            cursor: pointer;
            transition: all var(--transition-normal);
            font-family: var(--font-family-mono);
        }

        .filter-tag:hover,
        .filter-tag.active {
            background: var(--primary-green);
            color: var(--text-inverse);
            border-color: var(--primary-green);
        }

        /* Zoom controls */
        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .zoom-btn {
            background: var(--bg-secondary);
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            color: var(--text-secondary);
            padding: 8px 12px;
            font-size: 16px;
            cursor: pointer;
            transition: all var(--transition-normal);
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: var(--primary-green);
            color: var(--text-inverse);
            border-color: var(--primary-green);
        }

        /* Responsive */
        @media (max-width: 768px) {
            .controls {
                flex-direction: row;
                flex-wrap: wrap;
            }

            .control-btn {
                min-width: 100px;
                padding: 8px 12px;
                font-size: 11px;
            }

            .filter-panel {
                bottom: 80px;
                min-width: 160px;
            }

            .info-panel {
                max-width: 280px;
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="network-container" id="networkContainer">
        <div class="network-canvas" id="networkCanvas">
            <svg class="network-svg" id="networkSvg">
                <defs>
                    <marker id="arrowhead" markerWidth="10" markerHeight="7" 
                            refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#6c7086" />
                    </marker>
                </defs>
            </svg>
            <div class="network-cards" id="networkCards"></div>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <button class="control-btn" onclick="resetView()">Reset View</button>
        <button class="control-btn" onclick="showClusters()">Show Clusters</button>
        <button class="control-btn" onclick="generateLabels()">Auto Labels</button>
        <button class="control-btn" onclick="analyzeDensity()">Analyze Density</button>
        <button class="control-btn" onclick="rearrangeCards()">Auto Layout</button>
        <button class="control-btn" onclick="exportNetwork()">Export</button>
    </div>

    <!-- Info Panel -->
    <div class="info-panel" id="infoPanel">
        <div class="info-title" id="infoTitle">Select a Card</div>
        <div class="info-content" id="infoContent">
            Click on any card to see detailed information and connections.
        </div>
        <div class="info-metadata" id="infoMetadata"></div>
        <div class="info-connections" id="infoConnections"></div>
    </div>

    <!-- Filter Panel -->
    <div class="filter-panel">
        <div class="filter-title">Filters</div>
        <div class="filter-group">
            <div class="filter-label">Tags</div>
            <div class="filter-tags" id="filterTags">
                <span class="filter-tag" data-tag="ux">UX</span>
                <span class="filter-tag" data-tag="psychology">Psychology</span>
                <span class="filter-tag" data-tag="design">Design</span>
                <span class="filter-tag" data-tag="research">Research</span>
                <span class="filter-tag" data-tag="behavior">Behavior</span>
            </div>
        </div>
        <div class="filter-group">
            <div class="filter-label">Type</div>
            <div class="filter-tags" id="filterTypes">
                <span class="filter-tag" data-type="insight">Insight</span>
                <span class="filter-tag" data-type="theme">Theme</span>
                <span class="filter-tag" data-type="concept">Concept</span>
                <span class="filter-tag" data-type="action">Action</span>
                <span class="filter-tag" data-type="question">Question</span>
            </div>
        </div>
    </div>

    <!-- Zoom Controls -->
    <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomIn()">+</button>
        <button class="zoom-btn" onclick="zoomOut()">‚àí</button>
    </div>

    <script>
        // Global variables
        let cards = [];
        let connections = [];
        let selectedCard = null;
        let isDragging = false;
        let dragStart = { x: 0, y: 0 };
        let transform = { x: 0, y: 0, scale: 1 };
        let activeFilters = { tags: [], types: [] };
        let detectedClusters = [];

        // Sample card data
        const sampleCards = [
            {
                id: 'card_001',
                title: '„É¶„Éº„Ç∂„Éº„ÅÆÊΩúÂú®„Éã„Éº„Ç∫',
                content: '„Äå‰Ωø„ÅÑ„ÇÑ„Åô„ÅÑ„Äç„Å®„ÅÑ„ÅÜË®ÄËëâ„ÅÆÂ••„Å´„ÅÇ„ÇãÁúü„ÅÆÊÑüÊÉÖ„ÇíÁêÜËß£„Åô„ÇãÂøÖË¶Å„Åå„ÅÇ„Çã„ÄÇË°®Èù¢ÁöÑ„Å™Ë¶ÅÊ±Ç„Åß„ÅØ„Å™„Åè„ÄÅÊ∑±Â±§ÂøÉÁêÜ„Å´ÊΩú„ÇÄÊú¨ÂΩì„ÅÆ„Éã„Éº„Ç∫„ÇíÊé¢„Çã„ÄÇ',
                type: 'insight',
                tags: ['ux', 'psychology'],
                author: 'Áî∞‰∏≠',
                createdAt: '2025-01-15',
                x: 300, y: 200
            },
            {
                id: 'card_002',
                title: 'ÊÑüÊÉÖ vs Ê©üËÉΩ',
                content: 'Ê©üËÉΩÁöÑ‰æ°ÂÄ§„Å®ÊÑüÊÉÖÁöÑ‰æ°ÂÄ§„ÅÆ„Éê„É©„É≥„Çπ„ÅåÈáçË¶Å„ÄÇÂÆåÁíß„Å™Ê©üËÉΩ„Åå„ÅÇ„Å£„Å¶„ÇÇÊÑüÊÉÖÁöÑ„Å™ÂÖ±ÊÑü„Åå„Å™„Åë„Çå„Å∞ÊÑõ„Åï„Çå„Å™„ÅÑ„Éó„É≠„ÉÄ„ÇØ„Éà„Å´„Å™„Çã„ÄÇ',
                type: 'theme',
                tags: ['design', 'psychology'],
                author: '‰ΩêËó§',
                createdAt: '2025-01-14',
                x: 500, y: 250
            },
            {
                id: 'card_003',
                title: '„Ç≥„É≥„ÉÜ„Ç≠„Çπ„Éà„ÅÆÈáçË¶ÅÊÄß',
                content: '„É¶„Éº„Ç∂„Éº„ÅåÁΩÆ„Åã„Çå„Å¶„ÅÑ„ÇãÁä∂Ê≥Å„ÇÑÊñáËÑà„Å´„Çà„Å£„Å¶„ÄÅÂêå„ÅòÊ©üËÉΩ„Åß„ÇÇ‰æ°ÂÄ§„ÅåÂ§ß„Åç„ÅèÂ§â„Çè„Çã„ÄÇ',
                type: 'insight',
                tags: ['ux', 'research'],
                author: 'Â±±Áî∞',
                createdAt: '2025-01-13',
                x: 200, y: 350
            },
            {
                id: 'card_004',
                title: '„Éó„É≠„Éà„Çø„Ç§„ÉóÊ§úË®º',
                content: '„Ç¢„Ç§„Éá„Ç¢„ÇíÁ¥†Êó©„ÅèÂΩ¢„Å´„Åó„Å¶„ÄÅÂÆüÈöõ„ÅÆ„É¶„Éº„Ç∂„Éº„Å®ÂØæË©±„Åó„Å™„Åå„ÇâÊîπÂñÑ„Çµ„Ç§„ÇØ„É´„ÇíÂõû„Åô„ÄÇ',
                type: 'action',
                tags: ['design', 'research'],
                author: 'Èà¥Êú®',
                createdAt: '2025-01-12',
                x: 450, y: 400
            },
            {
                id: 'card_005',
                title: 'Ë™çÁü•Ë≤†Ëç∑„ÅÆËªΩÊ∏õ',
                content: '„É¶„Éº„Ç∂„Éº„ÅÆË™çÁü•Ë≤†Ëç∑„Çí‰∏ã„Åí„Çã„Åì„Å®„Åß„ÄÅ„Çà„ÇäÁõ¥ÊÑüÁöÑ„Åß‰Ωø„ÅÑ„ÇÑ„Åô„ÅÑ‰ΩìÈ®ì„ÇíÊèê‰æõ„Åß„Åç„Çã„ÄÇ',
                type: 'concept',
                tags: ['ux', 'psychology'],
                author: 'Áî∞‰∏≠',
                createdAt: '2025-01-11',
                x: 350, y: 300
            },
            {
                id: 'card_006',
                title: '„Å™„ÅúÊÑõ„Åï„Çå„Å™„ÅÑ„ÅÆ„ÅãÔºü',
                content: 'Ê©üËÉΩ„ÅØÂÆåÁíß„Å™„ÅÆ„Å´„ÄÅ„Å™„Åú„É¶„Éº„Ç∂„Éº„Å´ÊÑõ„Åï„Çå„Å™„ÅÑ„Éó„É≠„ÉÄ„ÇØ„Éà„Å´„Å™„Å£„Å¶„Åó„Åæ„ÅÜ„ÅÆ„ÅãÔºü',
                type: 'question',
                tags: ['psychology', 'behavior'],
                author: 'È´òÊ©ã',
                createdAt: '2025-01-10',
                x: 600, y: 200
            },
            {
                id: 'card_007',
                title: '„Ç®„É¢„Éº„Ç∑„Éß„Éä„É´„Éá„Ç∂„Ç§„É≥',
                content: '„É¶„Éº„Ç∂„Éº„ÅÆÊÑüÊÉÖ„Å´Ë®¥„Åà„Åã„Åë„Çã„Éá„Ç∂„Ç§„É≥„ÅÆÂäõ„ÄÇÊ©üËÉΩ„Å†„Åë„Åß„Å™„Åè„ÄÅ‰ΩìÈ®ìÂÖ®‰Ωì„ÇíË®≠Ë®à„Åô„Çã„ÄÇ',
                type: 'theme',
                tags: ['design', 'psychology'],
                author: 'Êûó',
                createdAt: '2025-01-09',
                x: 700, y: 300
            },
            {
                id: 'card_008',
                title: '„É¶„Éº„Ç∂„Éì„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà',
                content: 'ÂÆöÊúüÁöÑ„Å™„É¶„Éº„Ç∂„Éì„É™„ÉÜ„Ç£„ÉÜ„Çπ„Éà„Åß„ÄÅÊÉ≥ÂÆö„Å®ÁèæÂÆü„ÅÆ„ÇÆ„É£„ÉÉ„Éó„ÇíÁô∫Ë¶ã„ÅóÁ∂ö„Åë„Çã„ÄÇ',
                type: 'action',
                tags: ['research', 'ux'],
                author: '‰ΩêËó§',
                createdAt: '2025-01-08',
                x: 150, y: 450
            }
        ];

        const sampleConnections = [
            { from: 'card_001', to: 'card_002', type: 'relates_to', strength: 0.8 },
            { from: 'card_001', to: 'card_005', type: 'supports', strength: 0.7 },
            { from: 'card_002', to: 'card_007', type: 'leads_to', strength: 0.9 },
            { from: 'card_003', to: 'card_001', type: 'supports', strength: 0.6 },
            { from: 'card_004', to: 'card_008', type: 'relates_to', strength: 0.8 },
            { from: 'card_005', to: 'card_007', type: 'enables', strength: 0.7 },
            { from: 'card_006', to: 'card_001', type: 'questions', strength: 0.9 },
            { from: 'card_006', to: 'card_002', type: 'questions', strength: 0.8 },
            { from: 'card_007', to: 'card_001', type: 'implements', strength: 0.7 },
            { from: 'card_008', to: 'card_003', type: 'validates', strength: 0.6 }
        ];

        // Initialize
        function init() {
            cards = [...sampleCards];
            connections = [...sampleConnections];
            
            setupEventListeners();
            render();
            setupFilters();
            
            console.log('üï∏Ô∏è Card Network Map initialized');
        }

        function setupEventListeners() {
            const container = document.getElementById('networkContainer');
            
            // Mouse events for pan and zoom
            container.addEventListener('mousedown', startDrag);
            container.addEventListener('mousemove', drag);
            container.addEventListener('mouseup', endDrag);
            container.addEventListener('wheel', zoom);
            
            // Touch events for mobile
            container.addEventListener('touchstart', startDrag);
            container.addEventListener('touchmove', drag);
            container.addEventListener('touchend', endDrag);
            
            // Prevent context menu
            container.addEventListener('contextmenu', e => e.preventDefault());
        }

        function render() {
            renderCards();
            renderConnections();
        }

        function renderCards() {
            const container = document.getElementById('networkCards');
            container.innerHTML = '';

            const filteredCards = applyFilters(cards);

            filteredCards.forEach(card => {
                const cardEl = document.createElement('div');
                cardEl.className = `card type-${card.type}`;
                cardEl.style.left = `${card.x - 60}px`;
                cardEl.style.top = `${card.y - 40}px`;
                cardEl.onclick = () => selectCard(card);
                
                cardEl.innerHTML = `
                    <div class="card-meta">
                        <span class="card-author">${card.author}</span>
                        <span class="card-date">${formatDate(card.createdAt)}</span>
                    </div>
                    <div class="card-title">${card.title}</div>
                    <div class="card-tags">
                        ${card.tags.map(tag => `<span class="card-tag tag-${tag}">${tag}</span>`).join('')}
                    </div>
                `;
                
                container.appendChild(cardEl);
            });
        }

        function renderConnections() {
            const svg = document.getElementById('networkSvg');
            svg.innerHTML = svg.querySelector('defs').outerHTML;

            const filteredCards = applyFilters(cards);
            const filteredCardIds = new Set(filteredCards.map(c => c.id));

            connections.forEach(conn => {
                if (!filteredCardIds.has(conn.from) || !filteredCardIds.has(conn.to)) return;

                const fromCard = cards.find(c => c.id === conn.from);
                const toCard = cards.find(c => c.id === conn.to);
                
                if (fromCard && toCard) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', fromCard.x);
                    line.setAttribute('y1', fromCard.y);
                    line.setAttribute('x2', toCard.x);
                    line.setAttribute('y2', toCard.y);
                    line.setAttribute('class', `connection-line ${conn.strength > 0.7 ? 'strong' : ''}`);
                    
                    svg.appendChild(line);
                }
            });
        }

        function applyFilters(cardsToFilter) {
            return cardsToFilter.filter(card => {
                const tagMatch = activeFilters.tags.length === 0 || 
                                activeFilters.tags.some(tag => card.tags.includes(tag));
                const typeMatch = activeFilters.types.length === 0 || 
                                 activeFilters.types.includes(card.type);
                return tagMatch && typeMatch;
            });
        }

        function selectCard(card) {
            // Update selection
            document.querySelectorAll('.card').forEach(el => el.classList.remove('selected'));
            event.target.closest('.card').classList.add('selected');
            
            selectedCard = card;
            
            // Update info panel
            updateInfoPanel(card);
            
            // Highlight connections
            highlightConnections(card.id);
        }

        function updateInfoPanel(card) {
            const infoPanel = document.getElementById('infoPanel');
            const infoTitle = document.getElementById('infoTitle');
            const infoContent = document.getElementById('infoContent');
            const infoMetadata = document.getElementById('infoMetadata');
            const infoConnections = document.getElementById('infoConnections');
            
            infoTitle.textContent = card.title;
            infoContent.textContent = card.content;
            infoMetadata.innerHTML = `
                <strong>Author:</strong> ${card.author}<br>
                <strong>Created:</strong> ${formatDate(card.createdAt)}<br>
                <strong>Type:</strong> ${card.type}<br>
                <strong>Tags:</strong> ${card.tags.join(', ')}
            `;
            
            const relatedConnections = connections.filter(c => c.from === card.id || c.to === card.id);
            const connectionsHtml = relatedConnections.map(conn => {
                const otherCardId = conn.from === card.id ? conn.to : conn.from;
                const otherCard = cards.find(c => c.id === otherCardId);
                const direction = conn.from === card.id ? '‚Üí' : '‚Üê';
                return `
                    <div class="connection-item">
                        <span class="connection-type">${conn.type}</span>
                        <span>${direction} ${otherCard?.title || 'Unknown'}</span>
                    </div>
                `;
            }).join('');
            
            infoConnections.innerHTML = `
                <div class="info-connections-title">Connections (${relatedConnections.length})</div>
                ${connectionsHtml}
            `;
            
            infoPanel.classList.add('show');
        }

        function highlightConnections(cardId) {
            document.querySelectorAll('.connection-line').forEach(line => {
                line.classList.remove('active', 'related');
            });

            document.querySelectorAll('.card').forEach(card => {
                card.classList.remove('highlighted');
            });
            
            const relatedConnections = connections.filter(c => c.from === cardId || c.to === cardId);
            const relatedCardIds = new Set();
            
            relatedConnections.forEach(conn => {
                relatedCardIds.add(conn.from === cardId ? conn.to : conn.from);
            });

            // Highlight related cards
            document.querySelectorAll('.card').forEach(cardEl => {
                const card = cards.find(c => c.title === cardEl.querySelector('.card-title').textContent);
                if (card && relatedCardIds.has(card.id)) {
                    cardEl.classList.add('highlighted');
                }
            });

            // Highlight connection lines
            const lines = document.querySelectorAll('.connection-line');
            relatedConnections.forEach((conn, index) => {
                const lineIndex = connections.indexOf(conn);
                if (lines[lineIndex]) {
                    lines[lineIndex].classList.add('active');
                }
            });
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('ja-JP', { month: 'short', day: 'numeric' });
        }

        function setupFilters() {
            // Tag filters
            document.querySelectorAll('#filterTags .filter-tag').forEach(tag => {
                tag.addEventListener('click', function() {
                    const tagName = this.getAttribute('data-tag');
                    toggleFilter('tags', tagName);
                    this.classList.toggle('active');
                    render();
                });
            });

            // Type filters
            document.querySelectorAll('#filterTypes .filter-tag').forEach(tag => {
                tag.addEventListener('click', function() {
                    const typeName = this.getAttribute('data-type');
                    toggleFilter('types', typeName);
                    this.classList.toggle('active');
                    render();
                });
            });
        }

        function toggleFilter(filterType, value) {
            const filterArray = activeFilters[filterType];
            const index = filterArray.indexOf(value);
            if (index > -1) {
                filterArray.splice(index, 1);
            } else {
                filterArray.push(value);
            }
        }

        // Pan and Zoom functionality
        function startDrag(e) {
            if (e.target.closest('.card')) return;
            
            isDragging = true;
            const container = document.getElementById('networkContainer');
            container.classList.add('dragging');
            
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            
            dragStart.x = clientX - transform.x;
            dragStart.y = clientY - transform.y;
        }

        function drag(e) {
            if (!isDragging) return;
            
            e.preventDefault();
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            
            transform.x = clientX - dragStart.x;
            transform.y = clientY - dragStart.y;
            
            updateTransform();
        }

        function endDrag() {
            isDragging = false;
            const container = document.getElementById('networkContainer');
            container.classList.remove('dragging');
        }

        function zoom(e) {
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newScale = Math.max(0.2, Math.min(3, transform.scale * delta));
            
            if (newScale !== transform.scale) {
                transform.scale = newScale;
                updateTransform();
            }
        }

        function updateTransform() {
            const canvas = document.getElementById('networkCanvas');
            canvas.style.transform = `translate(${transform.x}px, ${transform.y}px) scale(${transform.scale})`;
        }

        // Control functions
        function resetView() {
            transform = { x: 0, y: 0, scale: 1 };
            updateTransform();
            
            document.querySelectorAll('.card').forEach(el => el.classList.remove('selected', 'highlighted'));
            document.getElementById('infoPanel').classList.remove('show');
            
            // Clear all visual overlays
            clearLabels();
            clearDensityIndicators();
            document.querySelectorAll('.cluster-highlight').forEach(el => el.remove());
            
            // Clear filters
            activeFilters = { tags: [], types: [] };
            document.querySelectorAll('.filter-tag').forEach(tag => tag.classList.remove('active'));
            render();
        }

        function generateLabels() {
            clearLabels();
            
            // Detect clusters first
            const currentClusters = detectClusters();
            
            // Generate labels for each cluster
            currentClusters.forEach((cluster, index) => {
                const clusterCards = cluster.map(id => cards.find(c => c.id === id)).filter(c => c);
                if (clusterCards.length < 2) return;

                const label = generateClusterLabel(clusterCards, index);
                const position = calculateLabelPosition(clusterCards);
                const theme = detectClusterTheme(clusterCards);
                
                createClusterLabel(label, position, theme, clusterCards.length);
            });

            // Generate region labels for sparse areas
            generateRegionLabels();
            
            console.log(`Generated labels for ${currentClusters.length} clusters`);
        }

        function generateClusterLabel(clusterCards, clusterIndex) {
            // Analyze tags frequency
            const tagFreq = {};
            const typeFreq = {};
            const keywordFreq = {};

            clusterCards.forEach(card => {
                // Count tags
                card.tags.forEach(tag => {
                    tagFreq[tag] = (tagFreq[tag] || 0) + 1;
                });
                
                // Count types
                typeFreq[card.type] = (typeFreq[card.type] || 0) + 1;
                
                // Extract keywords from titles
                const keywords = extractKeywords(card.title);
                keywords.forEach(keyword => {
                    keywordFreq[keyword] = (keywordFreq[keyword] || 0) + 1;
                });
            });

            // Find most common elements
            const topTag = Object.keys(tagFreq).reduce((a, b) => tagFreq[a] > tagFreq[b] ? a : b, '');
            const topType = Object.keys(typeFreq).reduce((a, b) => typeFreq[a] > typeFreq[b] ? a : b, '');
            const topKeyword = Object.keys(keywordFreq).reduce((a, b) => keywordFreq[a] > keywordFreq[b] ? a : b, '');

            // Generate intelligent label
            const labelStrategies = [
                // Tag-based labels
                () => {
                    const tagLabels = {
                        'ux': 'UX Research',
                        'psychology': 'Psychology',
                        'design': 'Design',
                        'research': 'Research',
                        'behavior': 'Behavior'
                    };
                    return tagLabels[topTag] || topTag.toUpperCase();
                },
                
                // Type-based labels
                () => {
                    const typeLabels = {
                        'insight': 'Insights',
                        'theme': 'Themes',
                        'concept': 'Concepts',
                        'action': 'Actions',
                        'question': 'Questions'
                    };
                    return typeLabels[topType] || topType;
                },
                
                // Keyword-based labels
                () => topKeyword && topKeyword.length > 2 ? topKeyword : null,
                
                // Combination labels
                () => {
                    if (topTag && topType) {
                        return `${topTag.toUpperCase()} ${topType}s`;
                    }
                    return null;
                },
                
                // Fallback
                () => `Cluster ${clusterIndex + 1}`
            ];

            // Try strategies in order
            for (const strategy of labelStrategies) {
                const label = strategy();
                if (label && label.length > 0) {
                    return label;
                }
            }

            return `Group ${clusterIndex + 1}`;
        }

        function extractKeywords(title) {
            // Simple keyword extraction
            const stopWords = ['„ÅÆ', '„Çí', '„Å´', '„ÅØ', '„Åå', '„Å®', '„Åß', '„Åã„Çâ', '„Åæ„Åß', '„Å´„Å§„ÅÑ„Å¶', '„Å´„Çà„Çã'];
            const words = title.toLowerCase()
                .replace(/[^\w\s]/g, '')
                .split(/\s+/)
                .filter(word => word.length > 2 && !stopWords.includes(word));
            
            return words;
        }

        function detectClusterTheme(clusterCards) {
            const tagCounts = {};
            clusterCards.forEach(card => {
                card.tags.forEach(tag => {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                });
            });

            const dominantTag = Object.keys(tagCounts).reduce((a, b) => 
                tagCounts[a] > tagCounts[b] ? a : b, '');

            const themeMapping = {
                'ux': 'ux',
                'psychology': 'psychology',
                'design': 'design',
                'research': 'research',
                'behavior': 'psychology'
            };

            return themeMapping[dominantTag] || 'default';
        }

        function calculateLabelPosition(clusterCards) {
            const centerX = clusterCards.reduce((sum, card) => sum + card.x, 0) / clusterCards.length;
            const centerY = clusterCards.reduce((sum, card) => sum + card.y, 0) / clusterCards.length;
            
            // Find the topmost position for label placement
            const minY = Math.min(...clusterCards.map(card => card.y));
            
            return {
                x: centerX,
                y: minY - 30 // Place label above the cluster
            };
        }

        function createClusterLabel(text, position, theme, cardCount) {
            const label = document.createElement('div');
            label.className = `cluster-label theme-${theme}`;
            
            // Size based on cluster size
            if (cardCount >= 5) {
                label.classList.add('size-large');
            } else if (cardCount <= 2) {
                label.classList.add('size-small');
            }
            
            label.textContent = text;
            label.style.left = `${position.x - 50}px`;
            label.style.top = `${position.y}px`;
            
            // Add to network cards container
            document.getElementById('networkCards').appendChild(label);
        }

        function generateRegionLabels() {
            // Divide canvas into regions and analyze card density
            const regions = analyzeRegions();
            
            regions.forEach(region => {
                if (region.cards.length > 0 && region.cards.length < 3) {
                    const label = generateRegionDescription(region);
                    if (label) {
                        createRegionLabel(label, region.center);
                    }
                }
            });
        }

        function analyzeRegions() {
            const gridSize = 150;
            const regions = [];
            
            for (let x = 0; x < 800; x += gridSize) {
                for (let y = 0; y < 600; y += gridSize) {
                    const regionCards = cards.filter(card => 
                        card.x >= x && card.x < x + gridSize &&
                        card.y >= y && card.y < y + gridSize
                    );
                    
                    if (regionCards.length > 0) {
                        regions.push({
                            bounds: { x, y, width: gridSize, height: gridSize },
                            center: { x: x + gridSize/2, y: y + gridSize/2 },
                            cards: regionCards,
                            density: regionCards.length
                        });
                    }
                }
            }
            
            return regions;
        }

        function generateRegionDescription(region) {
            const cards = region.cards;
            const types = [...new Set(cards.map(c => c.type))];
            const tags = [...new Set(cards.flatMap(c => c.tags))];
            
            if (cards.length === 1) {
                return `Isolated ${cards[0].type}`;
            }
            
            if (types.length === 1) {
                return `${types[0]}s`;
            }
            
            if (tags.length === 1) {
                return tags[0].toUpperCase();
            }
            
            return null;
        }

        function createRegionLabel(text, position) {
            const label = document.createElement('div');
            label.className = 'region-label';
            label.textContent = text;
            label.style.left = `${position.x - 30}px`;
            label.style.top = `${position.y}px`;
            
            document.getElementById('networkCards').appendChild(label);
        }

        function analyzeDensity() {
            clearDensityIndicators();
            
            const densityPoints = calculateDensityMap();
            
            densityPoints.forEach(point => {
                createDensityIndicator(point);
            });
            
            console.log(`Analyzed ${densityPoints.length} density points`);
        }

        function calculateDensityMap() {
            const gridSize = 100;
            const densityPoints = [];
            
            for (let x = 50; x < 750; x += gridSize) {
                for (let y = 50; y < 550; y += gridSize) {
                    const radius = 80;
                    const nearbyCards = cards.filter(card => {
                        const distance = Math.sqrt(
                            Math.pow(card.x - x, 2) + Math.pow(card.y - y, 2)
                        );
                        return distance <= radius;
                    });
                    
                    if (nearbyCards.length > 0) {
                        let densityLevel;
                        if (nearbyCards.length >= 4) densityLevel = 'high';
                        else if (nearbyCards.length >= 2) densityLevel = 'medium';
                        else densityLevel = 'low';
                        
                        densityPoints.push({
                            x, y,
                            density: nearbyCards.length,
                            level: densityLevel,
                            cards: nearbyCards
                        });
                    }
                }
            }
            
            return densityPoints;
        }

        function createDensityIndicator(point) {
            const indicator = document.createElement('div');
            indicator.className = `density-indicator ${point.level}`;
            indicator.style.left = `${point.x - 4}px`;
            indicator.style.top = `${point.y - 4}px`;
            indicator.title = `Density: ${point.density} cards`;
            
            document.getElementById('networkCards').appendChild(indicator);
        }

        function clearLabels() {
            document.querySelectorAll('.cluster-label, .region-label').forEach(el => el.remove());
        }

        function clearDensityIndicators() {
            document.querySelectorAll('.density-indicator').forEach(el => el.remove());
        }

        function showClusters() {
            // Clear existing visual elements
            clearLabels();
            clearDensityIndicators();
            
            // Detect clusters based on connection density
            detectedClusters = detectClusters();
            visualizeClusters();
        }

        function detectClusters() {
            // Build adjacency list for connected cards
            const adjacencyList = {};
            cards.forEach(card => {
                adjacencyList[card.id] = [];
            });

            connections.forEach(conn => {
                adjacencyList[conn.from].push(conn.to);
                adjacencyList[conn.to].push(conn.from);
            });

            const visited = new Set();
            const clusters = [];

            function dfs(cardId, cluster) {
                if (visited.has(cardId)) return;
                visited.add(cardId);
                cluster.push(cardId);

                adjacencyList[cardId].forEach(neighborId => {
                    if (!visited.has(neighborId)) {
                        dfs(neighborId, cluster);
                    }
                });
            }

            cards.forEach(card => {
                if (!visited.has(card.id)) {
                    const cluster = [];
                    dfs(card.id, cluster);
                    if (cluster.length > 1) {
                        clusters.push(cluster);
                    }
                }
            });

            return clusters;
        }

        function visualizeClusters() {
            const svg = document.getElementById('networkSvg');
            
            // Remove existing cluster highlights
            svg.querySelectorAll('.cluster-highlight').forEach(el => el.remove());

            detectedClusters.forEach((cluster, index) => {
                const clusterCards = cluster.map(id => cards.find(c => c.id === id)).filter(c => c);
                if (clusterCards.length < 2) return;

                // Calculate cluster bounds
                const minX = Math.min(...clusterCards.map(c => c.x)) - 80;
                const maxX = Math.max(...clusterCards.map(c => c.x)) + 80;
                const minY = Math.min(...clusterCards.map(c => c.y)) - 60;
                const maxY = Math.max(...clusterCards.map(c => c.y)) + 60;

                // Create cluster boundary
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', minX);
                rect.setAttribute('y', minY);
                rect.setAttribute('width', maxX - minX);
                rect.setAttribute('height', maxY - minY);
                rect.setAttribute('class', 'cluster-highlight');
                rect.setAttribute('rx', '20');
                
                svg.appendChild(rect);
            });

            console.log(`Found ${detectedClusters.length} clusters:`, detectedClusters);
        }

        function rearrangeCards() {
            // Simple force-directed layout
            const iterations = 100;
            const repulsion = 50000;
            const attraction = 0.01;
            const damping = 0.9;

            cards.forEach(card => {
                card.vx = 0;
                card.vy = 0;
            });

            for (let i = 0; i < iterations; i++) {
                // Repulsion between all cards
                for (let a = 0; a < cards.length; a++) {
                    for (let b = a + 1; b < cards.length; b++) {
                        const cardA = cards[a];
                        const cardB = cards[b];
                        
                        const dx = cardB.x - cardA.x;
                        const dy = cardB.y - cardA.y;
                        const distance = Math.sqrt(dx * dx + dy * dy) || 1;
                        
                        const force = repulsion / (distance * distance);
                        const fx = (dx / distance) * force;
                        const fy = (dy / distance) * force;
                        
                        cardA.vx -= fx;
                        cardA.vy -= fy;
                        cardB.vx += fx;
                        cardB.vy += fy;
                    }
                }

                // Attraction for connected cards
                connections.forEach(conn => {
                    const cardA = cards.find(c => c.id === conn.from);
                    const cardB = cards.find(c => c.id === conn.to);
                    
                    if (cardA && cardB) {
                        const dx = cardB.x - cardA.x;
                        const dy = cardB.y - cardA.y;
                        
                        const fx = dx * attraction * conn.strength;
                        const fy = dy * attraction * conn.strength;
                        
                        cardA.vx += fx;
                        cardA.vy += fy;
                        cardB.vx -= fx;
                        cardB.vy -= fy;
                    }
                });

                // Update positions
                cards.forEach(card => {
                    card.x += card.vx;
                    card.y += card.vy;
                    card.vx *= damping;
                    card.vy *= damping;

                    // Keep cards within bounds
                    card.x = Math.max(100, Math.min(700, card.x));
                    card.y = Math.max(100, Math.min(500, card.y));
                });
            }

            render();
        }

        function exportNetwork() {
            const data = { 
                cards: cards.map(card => ({
                    ...card,
                    vx: undefined,
                    vy: undefined
                })), 
                connections, 
                transform,
                filters: activeFilters
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'card-network.json';
            a.click();
            
            URL.revokeObjectURL(url);
            console.log('Network exported');
        }

        function zoomIn() {
            transform.scale = Math.min(3, transform.scale * 1.2);
            updateTransform();
        }

        function zoomOut() {
            transform.scale = Math.max(0.2, transform.scale / 1.2);
            updateTransform();
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            switch(e.key) {
                case 'r':
                case 'R':
                    resetView();
                    break;
                case 'c':
                case 'C':
                    showClusters();
                    break;
                case 'l':
                case 'L':
                    generateLabels();
                    break;
                case 'd':
                case 'D':
                    analyzeDensity();
                    break;
                case 'a':
                case 'A':
                    rearrangeCards();
                    break;
                case '+':
                case '=':
                    zoomIn();
                    break;
                case '-':
                    zoomOut();
                    break;
                case 'Escape':
                    document.querySelectorAll('.card').forEach(el => el.classList.remove('selected', 'highlighted'));
                    document.getElementById('infoPanel').classList.remove('show');
                    break;
            }
        });

        // Initialize on load
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>